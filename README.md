# ðŸŽ® Dialogue Maker â€“ Unity Integration UPM Package

This Unity project is the **runtime companion** for the [Dialogue Maker](https://github.com/rezdevir/Dialogue-Maker).

It loads and manages dialogue data created by writers, displaying it inside Unity scenes while allowing programmers to trigger in-game events through **actions**.

---

## ðŸ§© Overview

The system reads dialogue data generated by the WPF tool (`.json` format) and connects it to characters, emotions, and actions inside Unity.

Each dialogue line can:

- Display text with styles (color, speed, size, etc.)
- Change emotions dynamically
- Trigger an **Action Prefab**
- Branch to new dialogue paths

---

## ðŸ“ Folder Structure

All dialogue-related assets are stored under the `Resources` folder for runtime loading:

```bash
Assets
â”œâ”€â”€â”€DialogueSystem
â”‚   â”œâ”€â”€â”€Editor
â”‚   â””â”€â”€â”€sample
â”‚       â”œâ”€â”€â”€Prefabs
â”‚       â”‚   â”œâ”€â”€â”€Actions
â”‚       â”‚   â””â”€â”€â”€ChoiceIcon
â”‚       â””â”€â”€â”€UI
â”œâ”€â”€â”€Resources
â”‚   â””â”€â”€â”€Dialogues
â”‚       â”œâ”€â”€â”€Characters
â”‚       â”‚   â”œâ”€â”€â”€talking-clay-nothing
â”‚       â”‚   â””â”€â”€â”€talking-rez-nothing
â”‚       â””â”€â”€â”€JSONS
```

---

## ðŸ’¾ File & Folder Conventions

### ðŸ—ƒï¸ Dialogue Files

WPF app exports dialogue in `.json` format.  
Place all exported files here:

Assets/Resources/Dialogues/JSONS/

Example:

Assets/Resources/Dialogues/JSONS/intro_scene.json

### ðŸ§ Speaker Folders

Each character has its own folder containing sprites, portraits, or animation references.

Path:

```bash
Assets/Resources/Dialogues/Characters/
```

Each folder name follows this convention:

```bash
talking-[speaker_name]-[emotion]
```

Example:

```bash
talking-clay-nothing
talking-floy-happy
talking-rez-confuse
```

This naming format lets the system automatically load the correct portrait or animation based on the current lineâ€™s **speaker** and **emotion**.

---

## âš™ï¸ Action System (Prefab-Based)

Actions allow dialogue lines to trigger gameplay events (e.g., unlock a door, play a sound, start a cutscene).

### ðŸ”¹ How It Works

1. Each action defined in the `.json` file (from WPF tool) matches a **Prefab** in Unity.
2. These prefabs must be placed in your `Resources` folder for runtime loading.
3. Each Action Prefab contains a **MonoBehaviour script** that includes a public function to be called when triggered.

---

### ðŸ§± Example Structure

Assets/Resources/Dialogues/Actions/
â”œâ”€â”€ UnlockDoor.prefab
â”œâ”€â”€ ShowNote.prefab
â””â”€â”€ PlaySound.prefab

Each prefab can have a script with a callable method and Then you can select the specefic method even with Args:

![Action Image](https://raw.githubusercontent.com/rezdevir/CV/main/ds.png)

```csharp
using UnityEngine;

public class UnlockDoorAction : MonoBehaviour
{
    public void StartAction()
    {
        // Your custom logic here
        Debug.Log("Door unlocked!");
        // Example: DoorController.Instance.Unlock();
    }
}
```

When the dialogue reaches a line containing:

[Action: UnlockDoor]

â†’ the system will load the prefab named UnlockDoor from Resources/Dialogues/Actions/
â†’ and automatically call its StartAction() method.
ðŸ§  Integration Flow

    Writer: uses WPF Dialogue Maker to create .json file.

    Programmer: places that .json into Assets/Resources/Dialogues/JSONS/.

    System: automatically loads dialogues, links character portraits, and triggers action prefabs.

ðŸ”„ Example Runtime Flow

    The dialogue system loads intro_scene.json.

    The speaker is "clay", emotion "happy".
    â†’ System loads the portrait from
    Assets/Resources/Dialogues/Characters/talking-clay-happy.

    The text line finishes and includes [Action: PlaySound].
    â†’ System loads prefab PlaySound.prefab and calls its StartAction().

### Dialogues Whitin Events

You can access dialogue Start,End for whole and a line in game.

```csharp
    void Start()
    {

        DialogManager.Instance.OnEndDialogueLine += DialogLineEnd;
        DialogManager.Instance.OnStartDialogueLine += DialogLineStart;
        DialogManager.Instance.OnStartDialogue += DialogSystemStart;
        DialogManager.Instance.OnEndtDialogue += DialogSystemEnd;
    }
    void DialogLineEnd()
    {
        Debug.Log("At the end of Dialogue Line");
    }
    void DialogLineStart()
    {
        Debug.Log("Start of Dialogue Line");
    }
    void DialogSystemStart()
    {
        Debug.Log("Dialogue has started");
    }

        void DialogSystemEnd()
    {
        Debug.Log("Dialogue has Ended");
    }
```

### ðŸ§© Multiple Choice System

The Multiple Choice System allows the dialogue manager to display player choices dynamically based on the current dialogue context (speaker position and layout symmetry).

Components

```bash
multiple_choice_dispatcher
```

This component is responsible for spawning and managing multiple-choice UI buttons.

#### Main Responsibilities:

- Receives choice data from DialogManager through OnMultipleChoiceDelegate.

- Instantiates up to 4 choice buttons under its transform.

- Clears existing choices when a selection is made.

#### Differentiates between:

- Left/Right speaker: (Is_Left)

- Symmetric/Non-Symmetric layout: (Is_Symmetric)

#### Layout behavior:

- Non-symmetric (single speaker): uses Vertical Layout Group.

- Symmetric (two speakers): uses Horizontal Layout Group.

âš¡ Notes & Tips

    Keep prefab names case-sensitive to match the action names exactly.

    Use consistent folder naming â€” the system depends on it.

    Always test your dialogue after importing a new .json file.

    Avoid renaming or moving JSON files after export unless you update references.

ðŸ§° Dependencies

> Unity 2021.3+ (recommended)

> TextMeshPro (for dialogue rendering)

> JSON Utility or Newtonsoft.Json (for parsing dialogue data)

> This Package Support New Unity Input System

ðŸ‘¤ Author

Rez â€“ System Designer & Programmer
Focused on creating a unified workflow between writers and developers for faster, more flexible narrative systems in Unity.
