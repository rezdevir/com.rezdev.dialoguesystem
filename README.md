# 🎮 Dialogue Maker – Unity Integration UPM Package

This Unity project is the **runtime companion** for the [Dialogue Maker](https://github.com/rezdevir/Dialogue-Maker).

It loads and manages dialogue data created by writers, displaying it inside Unity scenes while allowing programmers to trigger in-game events through **actions**.

---

## 🧩 Overview

The system reads dialogue data generated by the WPF tool (`.json` format) and connects it to characters, emotions, and actions inside Unity.

Each dialogue line can:

- Display text with styles (color, speed, size, etc.)
- Change emotions dynamically
- Trigger an **Action Prefab**
- Branch to new dialogue paths

---

## 📁 Folder Structure

All dialogue-related assets are stored under the `Resources` folder for runtime loading:

```bash
Assets
├───DialogueSystem
│   ├───Editor
│   └───sample
│       ├───Prefabs
│       │   ├───Actions
│       │   └───ChoiceIcon
│       └───UI
├───Resources
│   └───Dialogues
│       ├───Characters
│       │   ├───talking-clay-nothing
│       │   └───talking-rez-nothing
│       └───JSONS
```

---

## 💾 File & Folder Conventions

### 🗃️ Dialogue Files

WPF app exports dialogue in `.json` format.  
Place all exported files here:

Assets/Resources/Dialogues/JSONS/

Example:

Assets/Resources/Dialogues/JSONS/intro_scene.json

### 🧍 Speaker Folders

Each character has its own folder containing sprites, portraits, or animation references.

Path:

```bash
Assets/Resources/Dialogues/Characters/
```

Each folder name follows this convention:

```bash
talking-[speaker_name]-[emotion]
```

Example:

```bash
talking-clay-nothing
talking-floy-happy
talking-rez-confuse
```

This naming format lets the system automatically load the correct portrait or animation based on the current line’s **speaker** and **emotion**.

---

## ⚙️ Action System (Prefab-Based)

Actions allow dialogue lines to trigger gameplay events (e.g., unlock a door, play a sound, start a cutscene).

### 🔹 How It Works

1. Each action defined in the `.json` file (from WPF tool) matches a **Prefab** in Unity.
2. These prefabs must be placed in your `Resources` folder for runtime loading.
3. Each Action Prefab contains a **MonoBehaviour script** that includes a public function to be called when triggered.

---

### 🧱 Example Structure

Assets/Resources/Dialogues/Actions/
├── UnlockDoor.prefab
├── ShowNote.prefab
└── PlaySound.prefab

Each prefab can have a script with a callable method and Then you can select the specefic method even with Args:

![Action Image](https://raw.githubusercontent.com/rezdevir/CV/main/ds.png)

```csharp
using UnityEngine;

public class UnlockDoorAction : MonoBehaviour
{
    public void StartAction()
    {
        // Your custom logic here
        Debug.Log("Door unlocked!");
        // Example: DoorController.Instance.Unlock();
    }
}
```

When the dialogue reaches a line containing:

[Action: UnlockDoor]

→ the system will load the prefab named UnlockDoor from Resources/Dialogues/Actions/
→ and automatically call its StartAction() method.
🧠 Integration Flow

    Writer: uses WPF Dialogue Maker to create .json file.

    Programmer: places that .json into Assets/Resources/Dialogues/JSONS/.

    System: automatically loads dialogues, links character portraits, and triggers action prefabs.

🔄 Example Runtime Flow

    The dialogue system loads intro_scene.json.

    The speaker is "clay", emotion "happy".
    → System loads the portrait from
    Assets/Resources/Dialogues/Characters/talking-clay-happy.

    The text line finishes and includes [Action: PlaySound].
    → System loads prefab PlaySound.prefab and calls its StartAction().

### Dialogues Whitin Events

You can access dialogue Start,End for whole and a line in game.

```csharp
    void Start()
    {

        DialogManager.Instance.OnEndDialogueLine += DialogLineEnd;
        DialogManager.Instance.OnStartDialogueLine += DialogLineStart;
        DialogManager.Instance.OnStartDialogue += DialogSystemStart;
        DialogManager.Instance.OnEndtDialogue += DialogSystemEnd;
    }
    void DialogLineEnd()
    {
        Debug.Log("At the end of Dialogue Line");
    }
    void DialogLineStart()
    {
        Debug.Log("Start of Dialogue Line");
    }
    void DialogSystemStart()
    {
        Debug.Log("Dialogue has started");
    }

        void DialogSystemEnd()
    {
        Debug.Log("Dialogue has Ended");
    }
```

### 🧩 Multiple Choice System

The Multiple Choice System allows the dialogue manager to display player choices dynamically based on the current dialogue context (speaker position and layout symmetry).

Components

```bash
multiple_choice_dispatcher
```

This component is responsible for spawning and managing multiple-choice UI buttons.

#### Main Responsibilities:

- Receives choice data from DialogManager through OnMultipleChoiceDelegate.

- Instantiates up to 4 choice buttons under its transform.

- Clears existing choices when a selection is made.

#### Differentiates between:

- Left/Right speaker: (Is_Left)

- Symmetric/Non-Symmetric layout: (Is_Symmetric)

#### Layout behavior:

- Non-symmetric (single speaker): uses Vertical Layout Group.

- Symmetric (two speakers): uses Horizontal Layout Group.

⚡ Notes & Tips

    Keep prefab names case-sensitive to match the action names exactly.

    Use consistent folder naming — the system depends on it.

    Always test your dialogue after importing a new .json file.

    Avoid renaming or moving JSON files after export unless you update references.

🧰 Dependencies

> Unity 2021.3+ (recommended)

> TextMeshPro (for dialogue rendering)

> JSON Utility or Newtonsoft.Json (for parsing dialogue data)

> This Package Support New Unity Input System

👤 Author

Rez – System Designer & Programmer
Focused on creating a unified workflow between writers and developers for faster, more flexible narrative systems in Unity.
